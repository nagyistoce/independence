/*
 *  MobDevInternals.cpp
 *  libPhoneInteraction
 *
 *  Created by The Operator on 28/01/08
 *  Copyright 2008 The Operator. All rights reserved.
 *
 *  This software is free software; you can redistribute it and/or
 *  modify it under the terms of the GNU General Public
 *  License version 2, as published by the Free Software Foundation.
 *
 *  This software is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 *
 *  See the GNU General Public License version 2 for more details 
 */

#include "MobDevInternals.h"
#include <stdio.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <fcntl.h>
#include <math.h>
#include <mach-o/fat.h>
#include <mach-o/arch.h>
#include <mach-o/loader.h>

#define MOBDEVPATH "/System/Library/PrivateFrameworks/MobileDevice.framework/MobileDevice"


enum {
	FUNC_SOCKETFORPORT = 0,
	FUNC_PERFORMOPERATION,
	FUNC_SENDCOMMANDTODEVICE,
	FUNC_SENDFILETODEVICE
};

static void swap_header(uint8_t *bytes, ssize_t length)
{
    ssize_t i;
	
    for (i = 0; i < length; i += 4) {
		*(uint32_t*)(bytes + i) = OSSwapInt32(*(uint32_t*)(bytes + i));
	}
	
}

static void swap_segmentcmd(uint8_t *bytes, ssize_t length)
{
    ssize_t i;
	
    for (i = 0; i < length; i += 4) {
		
		if (i == 8) {
			i += 16;
			continue;
		}
		
		*(uint32_t*)(bytes + i) = OSSwapInt32(*(uint32_t*)(bytes + i));
	}
	
}

static unsigned char *binaryFind(unsigned char *buffer, unsigned int bufLen,
								 unsigned char *pattern, unsigned int patLen)
{
	
	if (bufLen < patLen) {
		return NULL;
	}
	
	unsigned int offset = 0, matchedBytes = 0;
	
	while (offset < bufLen) {
		
		if (buffer[offset++] == pattern[matchedBytes++]) {
			
			if (matchedBytes == patLen) {
				return buffer + (offset - patLen);
			}
			
		}
		else {
			matchedBytes = 0;
		}
		
	}
	
	return NULL;
}

MobDevInternals::MobDevInternals()
{
	m_socketForPort = NULL;
	m_performOperation = NULL;
	m_sendCommandToDevice = NULL;
	m_sendFileToDevice = NULL;
	m_initializationError = NULL;
	m_mobDevBuffer = NULL;
	m_mobDevSize = 0;
	m_mobDevLoadOffset = 0;
	m_arch = ARCH_NATIVE;
	m_mobDevFile = MOBDEVPATH;
	m_bIsInitialized = SetupPrivateFunctions();
}

MobDevInternals::MobDevInternals(unsigned int arch, const char *file)
{
	m_socketForPort = NULL;
	m_performOperation = NULL;
	m_sendCommandToDevice = NULL;
	m_sendFileToDevice = NULL;
	m_initializationError = NULL;
	m_mobDevBuffer = NULL;
	m_mobDevSize = 0;
	m_mobDevLoadOffset = 0;
	m_arch = arch;
	m_mobDevFile = file;
	m_bIsInitialized = SetupPrivateFunctions();
}

MobDevInternals::~MobDevInternals()
{

	if (m_initializationError) {
		free(m_initializationError);
		m_initializationError = NULL;
	}

	if (m_mobDevBuffer) {
		free(m_mobDevBuffer);
		m_mobDevBuffer = NULL;
		m_mobDevSize = 0;
		m_mobDevLoadOffset = 0;
	}

}

bool MobDevInternals::IsInitialized()
{
	return m_bIsInitialized;
}

char *MobDevInternals::GetInitializationError()
{
	return m_initializationError;
}

void MobDevInternals::SetInitializationError(const char *msg)
{

	if (m_initializationError) {
		free(m_initializationError);
	}

	m_initializationError = (char*)malloc( (strlen(msg) + 1) * sizeof(char) );
	strcpy(m_initializationError, msg);
}

void MobDevInternals::PrintPrivateFunctionOffsets()
{

	if (IsInitialized()) {
		printf("SocketForPort: 0x%x\nPerformOperation: 0x%x\nSendCommandToDevice: 0x%x\nSendFileToDevice: 0x%x\n",
			   m_socketForPort, m_performOperation, m_sendCommandToDevice, m_sendFileToDevice);
	}

}

bool MobDevInternals::ParseMobDevMacho32(FILE *fp)
{

#ifdef DEBUG
	printf("ParseMobDevMacho32()\n");
#endif
	
	long startpos = ftell(fp);
	uint32_t magic;
	int size = sizeof(uint32_t);
	
	if (fread(&magic, size, 1, fp) < 1) {
		return false;
	}
	
	fseek(fp, startpos, SEEK_SET);
	
	if ( (magic != MH_MAGIC) && (magic != MH_CIGAM) ) {
		return false;
	}
	
	struct mach_header mh;
	size = sizeof(struct mach_header);
	
	if (fread(&mh, size, 1, fp) < 1) {
		return false;
	}
	
	if (magic == MH_CIGAM) {
		swap_header((uint8_t*)&mh, size);
	}
	
	struct load_command lc;
	int i;
	long pos;
	size = sizeof(struct load_command);
	
	struct section theSection;
	bool bFound = false;
	
	for (i = 0; i < mh.ncmds; i++) {
		pos = ftell(fp);
		
		if (fread(&lc, size, 1, fp) < 1) {
			return false;
		}
		
		if (magic == MH_CIGAM) {
			swap_header((uint8_t*)&lc, size);
		}
		
		if (lc.cmd == LC_SEGMENT) {
			fseek(fp, pos, SEEK_SET);
			
			int size2 = sizeof(struct segment_command);
			int bytesread = size2;
			struct segment_command sc;
			
			if (fread(&sc, size2, 1, fp) < 1) {
				return false;
			}
			
			if (magic == MH_CIGAM) {
				swap_segmentcmd((uint8_t*)&sc, size2);
			}
			
			if (!strcmp(sc.segname, "__TEXT")) {
				int j;
				struct section sect;
				size2 = sizeof(struct section);
				
				for (j = 0; j <  sc.nsects; j++) {
					
					if (fread(&sect, size2, 1, fp) < 1) {
						return false;
					}
					
					if (magic == MH_CIGAM) {
						swap_header(((uint8_t*)&sect) + 32, size2 - 32);
					}
					
					if (!strcmp(sect.sectname, "__text")) {
						theSection = sect;
						bFound = true;
						break;
					}
					
					bytesread += size2;
				}
				
			}

			if (bFound) {
				break;
			}

			fseek(fp, lc.cmdsize - bytesread, SEEK_CUR);
		}
		else {
			fseek(fp, lc.cmdsize - size, SEEK_CUR);
		}
		
	}
	
	if (bFound) {
		m_mobDevBuffer = (unsigned char*)malloc(theSection.size);
		m_mobDevSize = theSection.size;
		m_mobDevLoadOffset = theSection.addr;

		fseek(fp, startpos + theSection.offset, SEEK_SET);
		fread(m_mobDevBuffer, 1, theSection.size, fp);
	}

	return bFound;
}

bool MobDevInternals::OpenMobDevLibrary()
{

#ifdef DEBUG
	printf("OpenMobDevLibarary()\n");
#endif

	if (m_mobDevBuffer) {
		free(m_mobDevBuffer);
		m_mobDevBuffer = NULL;
		m_mobDevSize = 0;
		m_mobDevLoadOffset = 0;
	}

	FILE *fp = fopen(m_mobDevFile, "rb");

	if (fp == NULL) {
		return false;
	}
	
	uint32_t magic;
	int size = sizeof(uint32_t);
	
	if (fread(&magic, size, 1, fp) < 1) {
		fclose(fp);
		return false;
	}
	
	rewind(fp);
	
	if ( (magic == MH_MAGIC) || (magic == MH_CIGAM) ) {

		if (!ParseMobDevMacho32(fp)) {
			fclose(fp);
			return false;
		}

	}
	else if ( (magic == MH_MAGIC_64) || (magic == MH_CIGAM_64) ) {

		// TODO: Implement me
		/*
		if (!ParseMobDevMacho64(fp)) {
			fclose(fp);
			return false;
		}
		 */

		fclose(fp);
		return false;
	}
	else if ( (magic == FAT_MAGIC) || (magic == FAT_CIGAM) ) {
		struct fat_header fh;
		size = sizeof(struct fat_header);
		
		if (fread(&fh, size, 1, fp) < 1) {
			fclose(fp);
			return false;
		}
		
		if (magic == FAT_CIGAM) {
			swap_header((uint8_t*)&fh, size);
		}
		
		uint32_t i;
		struct fat_arch fa[fh.nfat_arch];
		size = sizeof(struct fat_arch);
		
		if (fread(fa, size, fh.nfat_arch, fp) < fh.nfat_arch) {
			fclose(fp);
			return false;
		}
		
		for (i = 0; i < fh.nfat_arch; i++) {
			
			if (magic == FAT_CIGAM) {
				swap_header((uint8_t*)(fa + i), size);
			}
			
		}
		
		const NXArchInfo *archInfo = NULL;

		switch (m_arch) {
			case ARCH_NATIVE:
				archInfo = NXGetLocalArchInfo();
				break;
			case ARCH_PPC:
				archInfo = NXGetArchInfoFromName("ppc");
				break;
			case ARCH_INTEL:
				archInfo = NXGetArchInfoFromName("i386");
				break;
			default:
				break;
		}

		struct fat_arch *arch = NXFindBestFatArch(archInfo->cputype,
												  archInfo->cpusubtype,
												  fa, fh.nfat_arch);
		fseek(fp, arch->offset, SEEK_SET);

		if (!ParseMobDevMacho32(fp)) {
			fclose(fp);
			return false;
		}
		
	}
	else {
		fclose(fp);
		return false;
	}
	
	fclose(fp);
	return true;
}

void *MobDevInternals::ScanMobDevForBinaryPatterns(unsigned char *patterns, unsigned int numpats,
												   unsigned int *patlens, unsigned int totalpatbytes,
												   long int sysversion)
{
#ifdef DEBUG
	printf("ScanMobDevForBinaryPatters()\n");
#endif
	
	if (m_mobDevBuffer == NULL) {
		return NULL;
	}

	unsigned char *ptr = m_mobDevBuffer, *ptr2;
	unsigned int bytesleft = m_mobDevSize, patoffset, found, i, j;
	unsigned int byteskip = 4;

	if (sysversion == gestaltPowerPC) {
		byteskip = 3;
	}

	while (bytesleft >= totalpatbytes) {

#ifdef DEBUG
		printf("Looping...\n");
#endif
		
		if ( (ptr = binaryFind(ptr, bytesleft, patterns, patlens[0])) == NULL ) {
			return NULL;
		}

#ifdef DEBUG
        printf("Found first pattern at offset 0x%x\n", (m_mobDevLoadOffset + (ptr - m_mobDevBuffer)));
#endif

		ptr = ptr + patlens[0];
		bytesleft = m_mobDevSize - (ptr - m_mobDevBuffer);

		ptr2 = ptr + byteskip;
		patoffset = patlens[0];
		found = 1;
		
		for (i = 1; i < numpats; i++) {

#ifdef DEBUG
            printf("Checking offset 0x%x for pattern %d...\n", (m_mobDevLoadOffset + (ptr2 - m_mobDevBuffer)), i+1);

            for (j = 0; j < patlens[i]; j++) {
                printf("ptr2[%d] = %1x, patterns[%d] = %1x\n", j, ptr2[j], j + patoffset, patterns[j+patoffset]);
            }
#endif

			if (memcmp(ptr2, patterns + patoffset, patlens[i])) {

#ifdef DEBUG
                printf("No match\n");
#endif
				found = 0;
				break;
			}

#ifdef DEBUG
			printf("Match\n");
#endif
			ptr2 = ptr2 + patlens[i] + byteskip;
			patoffset += patlens[i];
		}

		if (found) {
			return (void*)(m_mobDevLoadOffset + ((ptr - patlens[0]) - m_mobDevBuffer));
		}
		
	}
	
	return NULL;
}

void *MobDevInternals::ScanMobDevForSFP()
{

#ifdef DEBUG
	printf("ScanMobDevForSFP()\n");
#endif

	long int sysVersion = 0;

	switch (m_arch) {
		case ARCH_NATIVE:

			if (Gestalt(gestaltSysArchitecture, &sysVersion) != noErr) {
				return NULL;
			}

			break;
		case ARCH_PPC:
			sysVersion = gestaltPowerPC;
			break;
		case ARCH_INTEL:
			sysVersion = gestaltIntel;
			break;
		default:
			return NULL;
	}

	if (sysVersion == gestaltPowerPC) {
		unsigned int numpats = 6, funcbytes = 196;
		unsigned int patlens[] = { 61, 17, 61, 17, 1, 24 };
		unsigned char patterns[] = {
			0x7c, 0x08, 0x02, 0xa6, 0xbf, 0x81, 0xff, 0xf0,
			0x7c, 0x7c, 0x1b, 0x78, 0x42, 0x9f, 0x00, 0x05,
			0x7c, 0x9d, 0x23, 0x78, 0x3b, 0xc0, 0x00, 0x00,
			0x7f, 0xe8, 0x02, 0xa6, 0x90, 0x01, 0x00, 0x08,
			0x38, 0x00, 0xff, 0xff, 0x94, 0x21, 0xff, 0xa0,
			0x90, 0x01, 0x00, 0x38, 0x48, 0x00, 0x00, 0x14,
			0x2f, 0x9e, 0x00, 0x01, 0x40, 0x9d, 0x00, 0x0c,
			0x38, 0x60, 0x00, 0x0a, 0x48, 0x80, 0x7c, 0x00,
			0x18, 0x7f, 0xa4, 0xeb, 0x78, 0x38, 0xa1, 0x00,
			0x38, 0x3b, 0xde, 0x00, 0x01, 0x4b, 0x2f, 0x83,
			0x00, 0x00, 0x41, 0x9e, 0x00, 0x18, 0x2f, 0x9e,
			0x00, 0x05, 0x40, 0x9e, 0xff, 0xd0, 0x38, 0x00,
			0xff, 0xff, 0x90, 0x01, 0x00, 0x38, 0x48, 0x00,
			0x00, 0x40, 0x80, 0x61, 0x00, 0x38, 0x38, 0x80,
			0x00, 0x00, 0x38, 0x00, 0x00, 0x01, 0x38, 0xa0,
			0x10, 0x22, 0x38, 0xc1, 0x00, 0x3c, 0x60, 0x84,
			0xff, 0xff, 0x38, 0xe0, 0x00, 0x04, 0x90, 0x01,
			0x00, 0x3c, 0x48, 0x2f, 0x83, 0x00, 0x00, 0x40,
			0x9c, 0x00, 0x14, 0x3c, 0x9f, 0x00, 0x02, 0x38,
			0x60, 0x00, 0x04, 0x38, 0x48, 0x80, 0x61, 0x00,
            0x38, 0x38, 0x21, 0x00, 0x60, 0x80, 0x01, 0x00,
            0x08, 0xbb, 0x81, 0xff, 0xf0, 0x7c, 0x08, 0x03,
            0xa6, 0x4e, 0x80, 0x00, 0x20
		};
		
		return ScanMobDevForBinaryPatterns(patterns, numpats, patlens, funcbytes, sysVersion);
	}
	else if (sysVersion == gestaltIntel) {
		unsigned int numpats = 7, funcbytes = 190;
		unsigned int patlens[] = { 10, 40, 24, 63, 6, 12, 11 };
		unsigned char patterns[] = {
			0x55, 0x89, 0xe5, 0x57, 0x56, 0x53, 0x83, 0xec,
			0x4c, 0xe8, 0x89, 0x45, 0xd4, 0xc7, 0x45, 0xe4,
			0xff, 0xff, 0xff, 0xff, 0x31, 0xf6, 0x8d, 0x45,
			0xe4, 0x89, 0x45, 0xd0, 0x66, 0xc1, 0xc2, 0x08,
			0x0f, 0xb7, 0xfa, 0xeb, 0x11, 0x83, 0xfe, 0x01,
			0x7e, 0x0c, 0xc7, 0x04, 0x24, 0x0a, 0x00, 0x00,
			0x00, 0xe8, 0x83, 0xc6, 0x01, 0x8b, 0x55, 0xd0,
			0x89, 0x54, 0x24, 0x08, 0x89, 0x7c, 0x24, 0x04,
			0x8b, 0x55, 0xd4, 0x8b, 0x42, 0x18, 0x89, 0x04,
			0x24, 0xe8, 0x85, 0xc0, 0x74, 0x0e, 0x83, 0xfe,
			0x05, 0x75, 0xca, 0xc7, 0x45, 0xe4, 0xff, 0xff,
			0xff, 0xff, 0xeb, 0x4b, 0xc7, 0x45, 0xe0, 0x01,
			0x00, 0x00, 0x00, 0xc7, 0x44, 0x24, 0x10, 0x04,
			0x00, 0x00, 0x00, 0x8d, 0x45, 0xe0, 0x89, 0x44,
			0x24, 0x0c, 0xc7, 0x44, 0x24, 0x08, 0x22, 0x10,
			0x00, 0x00, 0xc7, 0x44, 0x24, 0x04, 0xff, 0xff,
			0x00, 0x00, 0x8b, 0x45, 0xe4, 0x89, 0x04, 0x24,
			0xe8, 0x85, 0xc0, 0x79, 0x16, 0x8d, 0x83, 0x89,
			0x44, 0x24, 0x04, 0xc7, 0x04, 0x24, 0x04, 0x00,
			0x00, 0x00, 0xe8, 0x8b, 0x45, 0xe4, 0x83, 0xc4,
			0x4c, 0x5b, 0x5e, 0x5f, 0x5d, 0xc3
		};

		return ScanMobDevForBinaryPatterns(patterns, numpats, patlens, funcbytes, sysVersion);

		// 0p: Work in progress...
		/*
		void *retval = ScanMobDevForBinaryPatterns(patterns, numpats, patlens, funcbytes, sysVersion);

		if (retval != NULL) return retval;

		// new binary patterns from iPhone SDK version of MobDev
		unsigned int numpats2 = 5, funcbytes2 = 199;
		unsigned int patlens2[] = { 53, 22, 66, 22, 20 };
		unsigned char patterns2[] = {
			0x55, 0x89, 0xe5, 0x57, 0x56, 0x31, 0xf6, 0x53,
			0xe8, 0x00, 0x00, 0x00, 0x00, 0x5b, 0x83, 0xec,
			0x4c, 0x66, 0xc1, 0xc2, 0x08, 0x89, 0x45, 0xd4,
			0x8d, 0x45, 0xe4, 0x0f, 0xb7, 0xfa, 0xc7, 0x45,
			0xe4, 0xff, 0xff, 0xff, 0xff, 0x89, 0x45, 0xd0,
			0x83, 0xfe, 0x01, 0x7e, 0x0c, 0xc7, 0x04, 0x24,
			0x0a, 0x00, 0x00, 0x00, 0xe8, 0x8b, 0x55, 0xd0,
			0x46, 0x89, 0x7c, 0x24, 0x04, 0x89, 0x54, 0x24,
			0x08, 0x8b, 0x55, 0xd4, 0x8b, 0x42, 0x18, 0x89,
			0x04, 0x24, 0xe8, 0x85, 0xc0, 0x89, 0xc1, 0x0f,
			0x95, 0xc2, 0x83, 0xfe, 0x04, 0x0f, 0x9e, 0xc0,
			0x84, 0xd0, 0x75, 0xc4, 0x85, 0xc9, 0x75, 0x4d,
			0x8d, 0x45, 0xe0, 0x89, 0x44, 0x24, 0x0c, 0x8b,
			0x45, 0xe4, 0xc7, 0x45, 0xe0, 0x01, 0x00, 0x00,
			0x00, 0xc7, 0x44, 0x24, 0x10, 0x04, 0x00, 0x00,
			0x00, 0xc7, 0x44, 0x24, 0x08, 0x22, 0x10, 0x00,
			0x00, 0xc7, 0x44, 0x24, 0x04, 0xff, 0xff, 0x00,
			0x00, 0x89, 0x04, 0x24, 0xe8, 0x85, 0xc0, 0x79,
			0x1f, 0x8d, 0x83, 0x89, 0xe1, 0xfe, 0x0f, 0x89,
			0x44, 0x24, 0x04, 0xc7, 0x04, 0x24, 0x04, 0x00,
			0x00, 0x00, 0xe8, 0xeb, 0x07, 0xc7, 0x45, 0xe4,
			0xff, 0xff, 0xff, 0xff, 0x8b, 0x45, 0xe4, 0x83,
			0xc4, 0x4c, 0x5b, 0x5e, 0x5f, 0xc9, 0xc3
		};

		return ScanMobDevForBinaryPatterns(patterns2, numpats2, patlens2, funcbytes2, sysVersion);
		 */
	}

	return NULL;
}

void *MobDevInternals::ScanMobDevForPO()
{

#ifdef DEBUG
	printf("ScanMobDevForPO()\n");
#endif

	long int sysVersion = 0;
	
	switch (m_arch) {
		case ARCH_NATIVE:
			
			if (Gestalt(gestaltSysArchitecture, &sysVersion) != noErr) {
				return NULL;
			}
			
			break;
		case ARCH_PPC:
			sysVersion = gestaltPowerPC;
			break;
		case ARCH_INTEL:
			sysVersion = gestaltIntel;
			break;
		default:
			return NULL;
	}
	
	if (sysVersion == gestaltPowerPC) {
		unsigned int numpats = 5, funcbytes = 120;
		unsigned int patlens[] = { 33, 9, 21, 17, 28 };
		unsigned char patterns[] = {
			0x7c, 0x08, 0x02, 0xa6, 0xbf, 0x81, 0xff, 0xf0,
			0x7c, 0x7c, 0x1b, 0x78, 0x7c, 0x9d, 0x23, 0x78,
			0x90, 0x01, 0x00, 0x08, 0x94, 0x21, 0xff, 0xa0,
			0x60, 0x00, 0x00, 0x00, 0x80, 0x63, 0x00, 0x20,
			0x48, 0x7c, 0x7e, 0x1b, 0x78, 0x7f, 0xa3, 0xeb,
			0x78, 0x48, 0x2f, 0x9e, 0x00, 0x00, 0x40, 0x9e,
			0x00, 0x2c, 0x7f, 0x83, 0xe3, 0x78, 0x38, 0x81,
			0x00, 0x38, 0x93, 0xc1, 0x00, 0x38, 0x4b, 0x7c,
			0x7e, 0x1b, 0x79, 0x40, 0x82, 0x00, 0x14, 0x80,
			0x81, 0x00, 0x38, 0x7f, 0x83, 0xe3, 0x78, 0x4b,
			0x7c, 0x7e, 0x1b, 0x78, 0x38, 0x21, 0x00, 0x60,
			0x7f, 0xc3, 0xf3, 0x78, 0x80, 0x01, 0x00, 0x08,
			0xbb, 0x81, 0xff, 0xf0, 0x7c, 0x08, 0x03, 0xa6,
			0x4e, 0x80, 0x00, 0x20
		};

		return ScanMobDevForBinaryPatterns(patterns, numpats, patlens, funcbytes, sysVersion);
	}
	else if (sysVersion == gestaltIntel) {
		unsigned int numpats = 5, funcbytes = 88;
		unsigned int patlens[] = { 24, 6, 18, 13, 11 };
		unsigned char patterns[] = {
			0x55, 0x89, 0xe5, 0x57, 0x56, 0x83, 0xec, 0x30,
			0x89, 0x45, 0xe4, 0x89, 0xd6, 0x89, 0x54, 0x24,
			0x04, 0x8b, 0x40, 0x20, 0x89, 0x04, 0x24, 0xe8,
			0x89, 0xc7, 0x89, 0x34, 0x24, 0xe8, 0x85, 0xff,
			0x75, 0x25, 0xc7, 0x45, 0xf4, 0x00, 0x00, 0x00,
			0x00, 0x8d, 0x55, 0xf4, 0x8b, 0x45, 0xe4, 0xe8,
			0x89, 0xc7, 0x85, 0xc0, 0x75, 0x0d, 0x8b, 0x55,
			0xf4, 0x8b, 0x45, 0xe4, 0xe8, 0x89, 0xc7, 0x89,
			0xf8, 0x83, 0xc4, 0x30, 0x5e, 0x5f, 0x5d, 0xc3		
		};
		
		return ScanMobDevForBinaryPatterns(patterns, numpats, patlens, funcbytes, sysVersion);

		// 0p: Work in progress...
		/*
		 void *retval = ScanMobDevForBinaryPatterns(patterns, numpats, patlens, funcbytes, sysVersion);
		 
		 if (retval != NULL) return retval;
		 
		 // new binary patterns from iPhone SDK version of MobDev
		 unsigned int numpats2 = 0, funcbytes2 = 0;
		 unsigned int patlens2[] = { };
		 unsigned char patterns2[] = {
			// oh performOperation() my friend, where have you gone?
		 };
		 
		 return ScanMobDevForBinaryPatterns(patterns2, numpats2, patlens2, funcbytes2, sysVersion);
		 */
	}

	return NULL;
}

void *MobDevInternals::ScanMobDevForSCTD()
{

#ifdef DEBUG
	printf("ScanMobDevForSCTD()\n");
#endif
	
	long int sysVersion = 0;
	
	switch (m_arch) {
		case ARCH_NATIVE:
			
			if (Gestalt(gestaltSysArchitecture, &sysVersion) != noErr) {
				return NULL;
			}
			
			break;
		case ARCH_PPC:
			sysVersion = gestaltPowerPC;
			break;
		case ARCH_INTEL:
			sysVersion = gestaltIntel;
			break;
		default:
			return NULL;
	}
	
	if (sysVersion == gestaltPowerPC) {
		unsigned int numpats = 7, funcbytes = 352;
		unsigned int patlens[] = { 61, 13, 1, 37, 77, 77, 68 };
		unsigned char patterns[] = {
			0x7c, 0x08, 0x02, 0xa6, 0xbf, 0x61, 0xff, 0xec,
			0x3c, 0xc0, 0x08, 0x00, 0x7c, 0x40, 0x00, 0x26,
			0x42, 0x9f, 0x00, 0x05, 0x90, 0x01, 0x00, 0x08,
			0x60, 0xc6, 0x01, 0x00, 0x38, 0xa0, 0x04, 0x00,
			0x7f, 0xe8, 0x02, 0xa6, 0x7c, 0x7b, 0x1b, 0x78,
			0x7c, 0x83, 0x23, 0x78, 0x90, 0x41, 0x00, 0x04,
			0x94, 0x21, 0xfb, 0x80, 0x3b, 0xc1, 0x00, 0x54,
			0x7f, 0xc4, 0xf3, 0x78, 0x48, 0x3c, 0x9f, 0x00,
			0x01, 0x7f, 0xc3, 0xf3, 0x78, 0x38, 0xa0, 0x04,
			0x00, 0x38, 0x48, 0x38, 0x00, 0x00, 0x01, 0x2b,
            0x83, 0x03, 0xff, 0x41, 0x9d, 0x00, 0xe4, 0x38,
            0x03, 0x00, 0x0f, 0x54, 0x1d, 0x00, 0x36, 0x7f,
            0x83, 0xe8, 0x40, 0x40, 0x9c, 0x00, 0x10, 0x7c,
            0x83, 0xe8, 0x50, 0x7c, 0x7e, 0x1a, 0x14, 0x48,
            0x2e, 0x1d, 0x00, 0x00, 0x7f, 0xdc, 0xf3, 0x78,
            0x48, 0x00, 0x00, 0xac, 0x38, 0x40, 0x00, 0x00,
            0x38, 0x00, 0x00, 0x0c, 0x93, 0xa1, 0x00, 0x3c,
            0x3b, 0xc1, 0x00, 0x3c, 0x7f, 0x63, 0xdb, 0x78,
            0x38, 0x80, 0x00, 0x03, 0x90, 0x01, 0x00, 0x38,
            0x98, 0x41, 0x00, 0x47, 0x7c, 0x00, 0xf4, 0x2c,
            0x38, 0xa0, 0x00, 0x08, 0x38, 0xc1, 0x00, 0x40,
            0xb0, 0x41, 0x00, 0x44, 0x98, 0x41, 0x00, 0x46,
            0x90, 0x01, 0x00, 0x40, 0x38, 0xe1, 0x00, 0x38,
            0x39, 0x01, 0x00, 0x48, 0x4b, 0x2f, 0x83, 0x00,
            0x00, 0x40, 0x9e, 0x00, 0x6c, 0x80, 0x01, 0x00,
            0x38, 0x2f, 0x80, 0x00, 0x00, 0x41, 0x9e, 0x00,
            0x60, 0x88, 0x01, 0x00, 0x48, 0x2f, 0x80, 0x00,
            0x08, 0x40, 0x9e, 0x00, 0x54, 0x80, 0x01, 0x00,
            0x4c, 0x90, 0x01, 0x00, 0x3c, 0x60, 0x00, 0x00,
            0x00, 0x60, 0x00, 0x00, 0x00, 0x7f, 0xc0, 0xf4,
            0x2c, 0x2f, 0x9e, 0x00, 0x00, 0x41, 0x9e, 0x00,
            0x2c, 0x7f, 0x63, 0xdb, 0x78, 0x38, 0x80, 0x00,
            0x01, 0x7f, 0x85, 0xe3, 0x78, 0x7f, 0xc6, 0xf3,
            0x78, 0x4b, 0x2f, 0x83, 0x00, 0x00, 0x40, 0x9e,
            0x00, 0x1c, 0x7f, 0xbe, 0xe8, 0x50, 0x7f, 0x9c,
            0xf2, 0x14, 0x2e, 0x1d, 0x00, 0x00, 0x40, 0x92,
            0xff, 0x58, 0x38, 0x00, 0x00, 0x00, 0x48, 0x00,
            0x00, 0x08, 0x38, 0x00, 0x00, 0x06, 0x38, 0x21,
            0x04, 0x80, 0x7c, 0x03, 0x03, 0x78, 0x80, 0x01,
            0x00, 0x08, 0x81, 0x61, 0x00, 0x04, 0xbb, 0x61,
            0xff, 0xec, 0x7c, 0x08, 0x03, 0xa6, 0x7d, 0x70,
            0x81, 0x20, 0x4e, 0x80, 0x00, 0x20
		};
		
		return ScanMobDevForBinaryPatterns(patterns, numpats, patlens, funcbytes, sysVersion);
	}
	else if (sysVersion == gestaltIntel) {
		unsigned int numpats = 8, funcbytes = 293;
		unsigned int patlens[] = { 13, 36, 10, 8, 44, 69, 45, 40 };
		unsigned char patterns[] = {
			0x55, 0x89, 0xe5, 0x57, 0x56, 0x53, 0x81, 0xec,
			0x4c, 0x04, 0x00, 0x00, 0xe8, 0x89, 0x85, 0xc0,
			0xfb, 0xff, 0xff, 0xc7, 0x44, 0x24, 0x0c, 0x00,
			0x01, 0x00, 0x08, 0xc7, 0x44, 0x24, 0x08, 0x00,
			0x04, 0x00, 0x00, 0x8d, 0xb5, 0xd0, 0xfb, 0xff,
			0xff, 0x89, 0x74, 0x24, 0x04, 0x89, 0x14, 0x24,
			0xe8, 0xc7, 0x44, 0x24, 0x08, 0x00, 0x04, 0x00,
			0x00, 0x8d, 0x83, 0x89, 0x44, 0x24, 0x04, 0x89,
			0x34, 0x24, 0xe8, 0x89, 0xc2, 0x3d, 0xff, 0x03,
			0x00, 0x00, 0x76, 0x0a, 0xb8, 0x01, 0x00, 0x00,
			0x00, 0xe9, 0xb4, 0x00, 0x00, 0x00, 0x8d, 0x78,
			0x0f, 0x83, 0xe7, 0xf0, 0x39, 0xf8, 0x73, 0x13,
			0x89, 0xf8, 0x29, 0xd0, 0x89, 0x44, 0x24, 0x04,
			0x8d, 0x04, 0x16, 0x89, 0x04, 0x24, 0xe8, 0x89,
			0xb5, 0xc4, 0xfb, 0xff, 0xff, 0xeb, 0x7e, 0xc7,
			0x45, 0xe4, 0x0c, 0x00, 0x00, 0x00, 0x89, 0x7d,
			0xdc, 0x66, 0xc7, 0x45, 0xe0, 0x00, 0x00, 0xc6,
			0x45, 0xe2, 0x00, 0xc6, 0x45, 0xe3, 0x00, 0x8d,
			0x45, 0xd0, 0x89, 0x44, 0x24, 0x08, 0x8d, 0x45,
			0xe4, 0x89, 0x44, 0x24, 0x04, 0x8d, 0x45, 0xdc,
			0x89, 0x04, 0x24, 0xb9, 0x08, 0x00, 0x00, 0x00,
			0xba, 0x03, 0x00, 0x00, 0x00, 0x8b, 0x85, 0xc0,
			0xfb, 0xff, 0xff, 0xe8, 0x85, 0xc0, 0x75, 0x45,
			0x8b, 0x75, 0xe4, 0x85, 0xf6, 0x74, 0x3e, 0x80,
			0x7d, 0xd0, 0x08, 0x75, 0x38, 0x8b, 0x75, 0xd4,
			0x85, 0xf6, 0x74, 0x25, 0x89, 0x34, 0x24, 0x8b,
			0x8d, 0xc4, 0xfb, 0xff, 0xff, 0xba, 0x01, 0x00,
			0x00, 0x00, 0x8b, 0x85, 0xc0, 0xfb, 0xff, 0xff,
			0xe8, 0x85, 0xc0, 0x75, 0x14, 0x29, 0xf7, 0x01,
			0xb5, 0xc4, 0xfb, 0xff, 0xff, 0x85, 0xff, 0x0f,
			0x85, 0x7a, 0xff, 0xff, 0xff, 0x31, 0xc0, 0xeb,
			0x05, 0xb8, 0x06, 0x00, 0x00, 0x00, 0x81, 0xc4,
			0x4c, 0x04, 0x00, 0x00, 0x5b, 0x5e, 0x5f, 0x5d,
			0xc3
		};

		return ScanMobDevForBinaryPatterns(patterns, numpats, patlens, funcbytes, sysVersion);
		
		// 0p: Work in progress...
		/*
		 void *retval = ScanMobDevForBinaryPatterns(patterns, numpats, patlens, funcbytes, sysVersion);
		
		if (retval != NULL) return retval;
		
		// new binary patterns from iPhone SDK version of MobDev
		unsigned int numpats2 = 6, funcbytes2 = 326;
		unsigned int patlens2[] = { 54, 22, 44, 102, 45, 39 };
		unsigned char patterns2[] = {
			0x55, 0x89, 0xe5, 0x57, 0x56, 0x53, 0xe8, 0x00,
			0x00, 0x00, 0x00, 0x5b, 0x81, 0xec, 0x4c, 0x04,
			0x00, 0x00, 0x8d, 0xb5, 0xd0, 0xfb, 0xff, 0xff,
			0x89, 0x14, 0x24, 0x89, 0x85, 0xc0, 0xfb, 0xff,
			0xff, 0xc7, 0x44, 0x24, 0x0c, 0x00, 0x01, 0x00,
			0x08, 0xc7, 0x44, 0x24, 0x08, 0x00, 0x04, 0x00,
			0x00, 0x89, 0x74, 0x24, 0x04, 0xe8, 0x8d, 0x83,
			0xb2, 0xd1, 0x00, 0x00, 0xc7, 0x44, 0x24, 0x08,
			0x00, 0x04, 0x00, 0x00, 0x89, 0x44, 0x24, 0x04,
			0x89, 0x34, 0x24, 0xe8, 0x89, 0xc2, 0xb8, 0x01,
			0x00, 0x00, 0x00, 0x81, 0xfa, 0xff, 0x03, 0x00,
			0x00, 0x0f, 0x87, 0xce, 0x00, 0x00, 0x00, 0x8d,
			0x7a, 0x0f, 0x83, 0xe7, 0xf0, 0x39, 0xfa, 0x73,
			0x13, 0x89, 0xf8, 0x29, 0xd0, 0x89, 0x44, 0x24,
			0x04, 0x8d, 0x04, 0x16, 0x89, 0x04, 0x24, 0xe8,
			0x89, 0xb5, 0xc4, 0xfb, 0xff, 0xff, 0xe9, 0x9c,
			0x00, 0x00, 0x00, 0xb8, 0xff, 0xff, 0xff, 0xff,
			0xe9, 0x9c, 0x00, 0x00, 0x00, 0xb8, 0x07, 0x00,
			0x00, 0x00, 0xe9, 0x92, 0x00, 0x00, 0x00, 0xb8,
			0xd3, 0x07, 0x00, 0x00, 0xe9, 0x88, 0x00, 0x00,
			0x00, 0x8d, 0x45, 0xd0, 0xb9, 0x08, 0x00, 0x00,
			0x00, 0x89, 0x44, 0x24, 0x08, 0x8d, 0x45, 0xe4,
			0xba, 0x03, 0x00, 0x00, 0x00, 0x89, 0x44, 0x24,
			0x04, 0x8d, 0x45, 0xdc, 0x89, 0x04, 0x24, 0x8b,
			0x85, 0xc0, 0xfb, 0xff, 0xff, 0xc7, 0x45, 0xe4,
			0x0c, 0x00, 0x00, 0x00, 0x89, 0x7d, 0xdc, 0x66,
			0xc7, 0x45, 0xe0, 0x00, 0x00, 0xc6, 0x45, 0xe2,
			0x00, 0xc6, 0x45, 0xe3, 0x00, 0xe8, 0x85, 0xc0,
			0x75, 0x43, 0x8b, 0x75, 0xe4, 0x85, 0xf6, 0x74,
			0x96, 0x80, 0x7d, 0xd0, 0x08, 0x75, 0x9a, 0x8b,
			0x75, 0xd4, 0x85, 0xf6, 0x74, 0x25, 0x8b, 0x8d,
			0xc4, 0xfb, 0xff, 0xff, 0xba, 0x01, 0x00, 0x00,
			0x00, 0x8b, 0x85, 0xc0, 0xfb, 0xff, 0xff, 0x89,
			0x34, 0x24, 0xe8, 0x85, 0xc0, 0x75, 0x80, 0x01,
			0xb5, 0xc4, 0xfb, 0xff, 0xff, 0x29, 0xf7, 0x85,
			0xff, 0x0f, 0x85, 0x7a, 0xff, 0xff, 0xff, 0x31,
			0xc0, 0x81, 0xc4, 0x4c, 0x04, 0x00, 0x00, 0x5b,
			0x5e, 0x5f, 0xc9, 0xc3, 0x55, 0x89, 0xe5, 0x81,
			0xec, 0xd8			
		};
		
		return ScanMobDevForBinaryPatterns(patterns2, numpats2, patlens2, funcbytes2, sysVersion);
		 */
	}
	
	return NULL;
}

void *MobDevInternals::ScanMobDevForSFTD()
{

#ifdef DEBUG
	printf("ScanMobDevForSFTD()\n");
#endif
	
	long int sysVersion = 0;
	
	switch (m_arch) {
		case ARCH_NATIVE:
			
			if (Gestalt(gestaltSysArchitecture, &sysVersion) != noErr) {
				return NULL;
			}
			
			break;
		case ARCH_PPC:
			sysVersion = gestaltPowerPC;
			break;
		case ARCH_INTEL:
			sysVersion = gestaltIntel;
			break;
		default:
			return NULL;
	}
	
	if (sysVersion == gestaltPowerPC) {
		unsigned int numpats = 19, funcbytes = 552;
		unsigned int patlens[] = {
			45, 13, 17, 13, 1, 9, 109, 25, 29, 65,
			29, 53, 5, 29, 1, 5, 13, 13, 24
		};
		unsigned char patterns[] = {
			0x7c, 0x08, 0x02, 0xa6, 0xbf, 0x01, 0xff, 0xe0,
			0x38, 0xa0, 0x04, 0x00, 0x42, 0x9f, 0x00, 0x05,
			0x7c, 0x79, 0x1b, 0x78, 0x7c, 0x83, 0x23, 0x78,
			0x7f, 0xe8, 0x02, 0xa6, 0x90, 0x01, 0x00, 0x08,
			0x94, 0x21, 0xfb, 0x20, 0x3b, 0xa1, 0x00, 0xb4,
			0x7f, 0xa4, 0xeb, 0x78, 0x48, 0x7f, 0xa3, 0xeb,
			0x78, 0x38, 0x80, 0x00, 0x00, 0x38, 0xa0, 0x00,
			0x00, 0x48, 0x2f, 0x83, 0xff, 0xff, 0x7c, 0x7b,
			0x1b, 0x78, 0x41, 0x9e, 0x00, 0x1c, 0x38, 0x81,
			0x00, 0x54, 0x48, 0x2f, 0x83, 0xff, 0xff, 0x40,
			0x9e, 0x00, 0x24, 0x7f, 0x63, 0xdb, 0x78, 0x48,
			0x48, 0x38, 0x80, 0x00, 0x0b, 0x80, 0x63, 0x00,
			0x00, 0x4b, 0x7c, 0x7c, 0x1b, 0x78, 0x48, 0x00,
			0x01, 0x98, 0x81, 0x21, 0x00, 0x84, 0x81, 0x41,
			0x00, 0x88, 0x2f, 0x89, 0x00, 0x00, 0x41, 0x9d,
			0x00, 0x14, 0x40, 0x9e, 0x00, 0x1c, 0x3c, 0x00,
			0x02, 0x00, 0x7f, 0x8a, 0x00, 0x40, 0x40, 0x9d,
			0x00, 0x10, 0x7f, 0x63, 0xdb, 0x78, 0x3b, 0x80,
			0x00, 0x01, 0x48, 0x00, 0x00, 0x58, 0x38, 0x00,
			0x00, 0x0c, 0x38, 0x40, 0x00, 0x09, 0x91, 0x41,
			0x00, 0x3c, 0x3b, 0xc1, 0x00, 0x3c, 0x7f, 0x23,
			0xcb, 0x78, 0x38, 0x80, 0x00, 0x05, 0x90, 0x01,
			0x00, 0x38, 0x90, 0x41, 0x00, 0x44, 0x7c, 0x00,
			0xf4, 0x2c, 0x38, 0xa0, 0x00, 0x08, 0x38, 0xc1,
			0x00, 0x40, 0x90, 0x01, 0x00, 0x40, 0x38, 0xe1,
			0x00, 0x38, 0x39, 0x01, 0x00, 0x48, 0x4b, 0x7c,
			0x7c, 0x1b, 0x79, 0x40, 0x82, 0x00, 0x10, 0x80,
			0x01, 0x00, 0x38, 0x2f, 0x80, 0x00, 0x00, 0x40,
			0x9e, 0x00, 0x10, 0x7f, 0x63, 0xdb, 0x78, 0x48,
			0x48, 0x00, 0x01, 0x10, 0x80, 0x01, 0x00, 0x4c,
			0x90, 0x01, 0x00, 0x3c, 0x60, 0x00, 0x00, 0x00,
			0x60, 0x00, 0x00, 0x00, 0x7f, 0x00, 0xf4, 0x2c,
			0x7f, 0x03, 0xc3, 0x78, 0x48, 0x83, 0xa1, 0x00,
			0x84, 0x83, 0xc1, 0x00, 0x88, 0x7c, 0x7a, 0x1b,
			0x78, 0x48, 0x00, 0x00, 0x70, 0x38, 0x40, 0x00,
			0x00, 0x7f, 0x03, 0xc3, 0x78, 0x7f, 0xc6, 0xf3,
			0x78, 0x7f, 0x82, 0xe8, 0x00, 0x41, 0x9d, 0x00,
			0x14, 0x40, 0x9e, 0x00, 0x0c, 0x7f, 0x98, 0xf0,
			0x40, 0x41, 0x9d, 0x00, 0x08, 0x7c, 0x66, 0x1b,
			0x78, 0x7c, 0xc5, 0x33, 0x78, 0x7f, 0x63, 0xdb,
			0x78, 0x7f, 0x44, 0xd3, 0x78, 0x48, 0x2f, 0x83,
			0xff, 0xff, 0x7c, 0x7c, 0x1b, 0x78, 0x41, 0x9e,
			0x00, 0x44, 0x7f, 0x23, 0xcb, 0x78, 0x38, 0x80,
			0x00, 0x00, 0x7f, 0x45, 0xd3, 0x78, 0x7f, 0x86,
			0xe3, 0x78, 0x4b, 0x2f, 0x83, 0x00, 0x00, 0x40,
			0x9e, 0x00, 0x28, 0x7f, 0x83, 0xe3, 0x78, 0x7f,
			0x82, 0xfe, 0x70, 0x7f, 0xc3, 0xf0, 0x10, 0x7f,
			0xa2, 0xe9, 0x10, 0x2f, 0x9d, 0x00, 0x00, 0x41,
			0x9d, 0xff, 0x90, 0x40, 0x9e, 0x00, 0x0c, 0x2b,
			0x9e, 0x00, 0x00, 0x41, 0x9d, 0xff, 0x84, 0x7f,
			0x63, 0xdb, 0x78, 0x3b, 0x80, 0x00, 0x06, 0x48,
			0x7f, 0x43, 0xd3, 0x78, 0x48, 0x7f, 0xa0, 0xf3,
			0x79, 0x40, 0x82, 0x00, 0x48, 0x3c, 0x5f, 0x00,
			0x01, 0x80, 0xc1, 0x00, 0x84, 0x80, 0xe1, 0x00,
			0x88, 0x3c, 0xbf, 0x00, 0x01, 0x38, 0x80, 0x00,
			0x00, 0x80, 0x38, 0x80, 0x62, 0x00, 0x00, 0x48,
            0x7c, 0x7d, 0x1b, 0x78, 0x7f, 0x23, 0xcb, 0x78,
            0x7f, 0xa4, 0xeb, 0x78, 0x4b, 0x7c, 0x60, 0x1b,
            0x78, 0x7f, 0xa3, 0xeb, 0x78, 0x7c, 0x1c, 0x03,
            0x78, 0x48, 0x38, 0x21, 0x04, 0xe0, 0x7f, 0x83,
            0xe3, 0x78, 0x80, 0x01, 0x00, 0x08, 0xbb, 0x01,
            0xff, 0xe0, 0x7c, 0x08, 0x03, 0xa6, 0x4e, 0x80,
            0x00, 0x20
		};
		
		return ScanMobDevForBinaryPatterns(patterns, numpats, patlens, funcbytes, sysVersion);
	}
	else if (sysVersion == gestaltIntel) {
		unsigned int numpats = 21, funcbytes = 616;
		unsigned int patlens[] = {
			13, 28, 20, 31, 15, 1, 14, 37, 64, 23,
			12, 103, 25, 53, 10, 37, 14, 6, 11, 6,
			13
		};
		unsigned char patterns[] = {
			0x55, 0x89, 0xe5, 0x57, 0x56, 0x53, 0x81, 0xec,
			0xcc, 0x04, 0x00, 0x00, 0xe8, 0x89, 0x85, 0x58,
			0xfb, 0xff, 0xff, 0xc7, 0x44, 0x24, 0x08, 0x00,
			0x04, 0x00, 0x00, 0x8d, 0xb5, 0x70, 0xfb, 0xff,
			0xff, 0x89, 0x74, 0x24, 0x04, 0x89, 0x14, 0x24,
			0xe8, 0xc7, 0x44, 0x24, 0x08, 0x00, 0x00, 0x00,
			0x00, 0xc7, 0x44, 0x24, 0x04, 0x00, 0x00, 0x00,
			0x00, 0x89, 0x34, 0x24, 0xe8, 0x89, 0x85, 0x5c,
			0xfb, 0xff, 0xff, 0x83, 0xc0, 0x01, 0x74, 0x2b,
			0x8d, 0x85, 0x70, 0xff, 0xff, 0xff, 0x89, 0x44,
			0x24, 0x04, 0x8b, 0x85, 0x5c, 0xfb, 0xff, 0xff,
			0x89, 0x04, 0x24, 0xe8, 0x83, 0xc0, 0x01, 0x75,
			0x2c, 0x8b, 0x95, 0x5c, 0xfb, 0xff, 0xff, 0x89,
			0x14, 0x24, 0xe8, 0xe8, 0xc7, 0x44, 0x24, 0x04,
			0x0b, 0x00, 0x00, 0x00, 0x8b, 0x00, 0x89, 0x04,
			0x24, 0xe8, 0x89, 0xc6, 0xe9, 0xbe, 0x01, 0x00,
			0x00, 0x8b, 0x45, 0xa0, 0x8b, 0x55, 0xa4, 0x83,
			0xfa, 0x00, 0x7c, 0x21, 0x7f, 0x07, 0x3d, 0x00,
			0x00, 0x00, 0x02, 0x76, 0x18, 0x8b, 0x8d, 0x5c,
			0xfb, 0xff, 0xff, 0x89, 0x0c, 0x24, 0xe8, 0xbe,
			0x01, 0x00, 0x00, 0x00, 0xe9, 0x92, 0x01, 0x00,
			0x00, 0xc7, 0x45, 0xe4, 0x0c, 0x00, 0x00, 0x00,
			0x89, 0x45, 0xdc, 0xc7, 0x45, 0xe0, 0x00, 0x00,
			0x00, 0x09, 0x8d, 0x45, 0xd0, 0x89, 0x44, 0x24,
			0x08, 0x8d, 0x45, 0xe4, 0x89, 0x44, 0x24, 0x04,
			0x8d, 0x45, 0xdc, 0x89, 0x04, 0x24, 0xb9, 0x08,
			0x00, 0x00, 0x00, 0xba, 0x05, 0x00, 0x00, 0x00,
			0x8b, 0x85, 0x58, 0xfb, 0xff, 0xff, 0xe8, 0x89,
			0xc6, 0x85, 0xc0, 0x75, 0x07, 0x8b, 0x7d, 0xe4,
			0x85, 0xff, 0x75, 0x13, 0x8b, 0x85, 0x5c, 0xfb,
			0xff, 0xff, 0x89, 0x04, 0x24, 0xe8, 0xe9, 0x38,
			0x01, 0x00, 0x00, 0x8b, 0x75, 0xd4, 0x89, 0x34,
			0x24, 0xe8, 0x89, 0x85, 0x54, 0xfb, 0xff, 0xff,
			0x8b, 0x55, 0xa0, 0x8b, 0x4d, 0xa4, 0x89, 0x95,
			0x60, 0xfb, 0xff, 0xff, 0x89, 0x8d, 0x64, 0xfb,
			0xff, 0xff, 0x89, 0xb5, 0x48, 0xfb, 0xff, 0xff,
			0xc7, 0x85, 0x4c, 0xfb, 0xff, 0xff, 0x00, 0x00,
			0x00, 0x00, 0xeb, 0x71, 0x8b, 0x85, 0x60, 0xfb,
			0xff, 0xff, 0x83, 0xbd, 0x64, 0xfb, 0xff, 0xff,
			0x00, 0x7c, 0x16, 0x7f, 0x0e, 0x8b, 0x8d, 0x48,
			0xfb, 0xff, 0xff, 0x39, 0x8d, 0x60, 0xfb, 0xff,
			0xff, 0x76, 0x06, 0x8b, 0x85, 0x48, 0xfb, 0xff,
			0xff, 0x89, 0x44, 0x24, 0x08, 0x8b, 0x85, 0x54,
			0xfb, 0xff, 0xff, 0x89, 0x44, 0x24, 0x04, 0x8b,
			0x95, 0x5c, 0xfb, 0xff, 0xff, 0x89, 0x14, 0x24,
			0xe8, 0x89, 0xc7, 0x83, 0xf8, 0xff, 0x74, 0x41,
			0x89, 0x04, 0x24, 0x8b, 0x8d, 0x54, 0xfb, 0xff,
			0xff, 0x31, 0xd2, 0x8b, 0x85, 0x58, 0xfb, 0xff,
			0xff, 0xe8, 0x85, 0xc0, 0x75, 0x27, 0x89, 0xf8,
			0x99, 0x29, 0xbd, 0x60, 0xfb, 0xff, 0xff, 0x19,
			0x95, 0x64, 0xfb, 0xff, 0xff, 0x83, 0xbd, 0x64,
			0xfb, 0xff, 0xff, 0x00, 0x7f, 0x86, 0x7c, 0x0d,
			0x83, 0xbd, 0x60, 0xfb, 0xff, 0xff, 0x00, 0x0f,
			0x87, 0x77, 0xff, 0xff, 0xff, 0x8b, 0x8d, 0x5c,
			0xfb, 0xff, 0xff, 0x89, 0x0c, 0x24, 0xe8, 0x8b,
			0x85, 0x54, 0xfb, 0xff, 0xff, 0x89, 0x04, 0x24,
			0xe8, 0x8b, 0x95, 0x64, 0xfb, 0xff, 0xff, 0x0b,
			0x95, 0x60, 0xfb, 0xff, 0xff, 0x74, 0x07, 0xbe,
			0x06, 0x00, 0x00, 0x00, 0xeb, 0x49, 0x8b, 0x45,
			0xa0, 0x8b, 0x55, 0xa4, 0x89, 0x44, 0x24, 0x0c,
			0x89, 0x54, 0x24, 0x10, 0x8d, 0x83, 0x89, 0x44,
			0x24, 0x08, 0xc7, 0x44, 0x24, 0x04, 0x00, 0x00,
			0x00, 0x00, 0x8b, 0x83, 0x8b, 0x00, 0x89, 0x04,
			0x24, 0xe8, 0x89, 0xc7, 0x89, 0xc2, 0x8b, 0x85,
			0x58, 0xfb, 0xff, 0xff, 0xe8, 0x89, 0xc6, 0x89,
			0x3c, 0x24, 0xe8, 0x89, 0xf0, 0x81, 0xc4, 0xcc,
			0x04, 0x00, 0x00, 0x5b, 0x5e, 0x5f, 0x5d, 0xc3
		};
		
		return ScanMobDevForBinaryPatterns(patterns, numpats, patlens, funcbytes, sysVersion);
		
		// 0p: Work in progress...
		/*
		 void *retval = ScanMobDevForBinaryPatterns(patterns, numpats, patlens, funcbytes, sysVersion);
		
		if (retval != NULL) return retval;
		
		// new binary patterns from iPhone SDK version of MobDev
		unsigned int numpats2 = 18, funcbytes2 = 606;
		unsigned int patlens2[] = {
			52, 20, 21, 7, 1, 14, 36, 59, 17, 32,
			97, 29, 55, 10, 58, 11, 6, 13
		};
		unsigned char patterns2[] = {
			0x55, 0x89, 0xe5, 0x81, 0xec, 0xd8, 0x04, 0x00,
			0x00, 0x89, 0x5d, 0xf4, 0xe8, 0x00, 0x00, 0x00,
			0x00, 0x5b, 0x89, 0x75, 0xf8, 0x8d, 0xb5, 0x70,
			0xfb, 0xff, 0xff, 0x89, 0x7d, 0xfc, 0x89, 0x14,
			0x24, 0x89, 0x85, 0x5c, 0xfb, 0xff, 0xff, 0xc7,
			0x44, 0x24, 0x08, 0x00, 0x04, 0x00, 0x00, 0x89,
			0x74, 0x24, 0x04, 0xe8, 0xc7, 0x44, 0x24, 0x08,
			0x00, 0x00, 0x00, 0x00, 0xc7, 0x44, 0x24, 0x04,
			0x00, 0x00, 0x00, 0x00, 0x89, 0x34, 0x24, 0xe8,
			0x83, 0xf8, 0xff, 0x89, 0xc7, 0x74, 0x1d, 0x8d,
			0x85, 0x70, 0xff, 0xff, 0xff, 0x89, 0x44, 0x24,
			0x04, 0x89, 0x3c, 0x24, 0xe8, 0x40, 0x75, 0x26,
			0x89, 0x3c, 0x24, 0xe8, 0xe8, 0xc7, 0x44, 0x24,
			0x04, 0x0b, 0x00, 0x00, 0x00, 0x8b, 0x00, 0x89,
			0x04, 0x24, 0xe8, 0x89, 0xc6, 0xe9, 0xbf, 0x01,
			0x00, 0x00, 0x8b, 0x55, 0xa4, 0x8b, 0x45, 0xa0,
			0x83, 0xfa, 0x00, 0x7c, 0x1b, 0x7f, 0x07, 0x3d,
			0x00, 0x00, 0x00, 0x02, 0x76, 0x12, 0x89, 0x3c,
			0x24, 0xbe, 0x01, 0x00, 0x00, 0x00, 0xe8, 0xe9,
			0x99, 0x01, 0x00, 0x00, 0x89, 0x45, 0xdc, 0x8d,
			0x45, 0xd0, 0xb9, 0x08, 0x00, 0x00, 0x00, 0x89,
			0x44, 0x24, 0x08, 0x8d, 0x45, 0xe4, 0xba, 0x05,
			0x00, 0x00, 0x00, 0x89, 0x44, 0x24, 0x04, 0x8d,
			0x45, 0xdc, 0x89, 0x04, 0x24, 0x8b, 0x85, 0x5c,
			0xfb, 0xff, 0xff, 0xc7, 0x45, 0xe4, 0x0c, 0x00,
			0x00, 0x00, 0xc7, 0x45, 0xe0, 0x00, 0x00, 0x00,
			0x09, 0xe8, 0x85, 0xc0, 0x89, 0xc6, 0x75, 0x07,
			0x8b, 0x45, 0xe4, 0x85, 0xc0, 0x75, 0x21, 0x89,
			0x3c, 0x24, 0xe8, 0xe9, 0x45, 0x01, 0x00, 0x00,
			0xbe, 0x0d, 0x00, 0x00, 0x00, 0xe9, 0xce, 0x00,
			0x00, 0x00, 0xbe, 0xd3, 0x07, 0x00, 0x00, 0xe9,
			0xc4, 0x00, 0x00, 0x00, 0x8b, 0x75, 0xd4, 0x89,
			0x34, 0x24, 0xe8, 0x8b, 0x55, 0xa4, 0x89, 0xb5,
			0x50, 0xfb, 0xff, 0xff, 0xc7, 0x85, 0x54, 0xfb,
			0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x89, 0x95,
			0x64, 0xfb, 0xff, 0xff, 0x89, 0x85, 0x58, 0xfb,
			0xff, 0xff, 0x8b, 0x45, 0xa0, 0x89, 0x85, 0x60,
			0xfb, 0xff, 0xff, 0xeb, 0x75, 0x83, 0xbd, 0x64,
			0xfb, 0xff, 0xff, 0x00, 0x8b, 0x85, 0x60, 0xfb,
			0xff, 0xff, 0x7c, 0x16, 0x7f, 0x0e, 0x8b, 0x8d,
			0x50, 0xfb, 0xff, 0xff, 0x39, 0x8d, 0x60, 0xfb,
			0xff, 0xff, 0x76, 0x06, 0x8b, 0x85, 0x50, 0xfb,
			0xff, 0xff, 0x89, 0x44, 0x24, 0x08, 0x8b, 0x85,
			0x58, 0xfb, 0xff, 0xff, 0x89, 0x3c, 0x24, 0x89,
			0x44, 0x24, 0x04, 0xe8, 0x83, 0xf8, 0xff, 0x89,
			0xc6, 0x0f, 0x84, 0x71, 0xff, 0xff, 0xff, 0x89,
			0x04, 0x24, 0x8b, 0x8d, 0x58, 0xfb, 0xff, 0xff,
			0x31, 0xd2, 0x8b, 0x85, 0x5c, 0xfb, 0xff, 0xff,
			0xe8, 0x85, 0xc0, 0x0f, 0x85, 0x5d, 0xff, 0xff,
			0xff, 0x89, 0xf2, 0xc1, 0xfa, 0x1f, 0x29, 0xb5,
			0x60, 0xfb, 0xff, 0xff, 0x19, 0x95, 0x64, 0xfb,
			0xff, 0xff, 0x83, 0xbd, 0x64, 0xfb, 0xff, 0xff,
			0x00, 0x7f, 0x82, 0x7c, 0x0d, 0x83, 0xbd, 0x60,
			0xfb, 0xff, 0xff, 0x00, 0x0f, 0x87, 0x73, 0xff,
			0xff, 0xff, 0x31, 0xf6, 0x89, 0x3c, 0x24, 0xe8,
			0x8b, 0x95, 0x58, 0xfb, 0xff, 0xff, 0x89, 0x14,
			0x24, 0xe8, 0x8b, 0x8d, 0x64, 0xfb, 0xff, 0xff,
			0x0b, 0x8d, 0x60, 0xfb, 0xff, 0xff, 0x75, 0x49,
			0x8b, 0x45, 0xa0, 0x8b, 0x55, 0xa4, 0xc7, 0x44,
			0x24, 0x04, 0x00, 0x00, 0x00, 0x00, 0x89, 0x44,
			0x24, 0x0c, 0x8d, 0x83, 0xad, 0x95, 0xfe, 0x0f,
			0x89, 0x44, 0x24, 0x08, 0x8b, 0x83, 0xa9, 0xcc,
			0xfe, 0x0f, 0x89, 0x54, 0x24, 0x10, 0x8b, 0x00,
			0x89, 0x04, 0x24, 0xe8, 0x89, 0xc7, 0x89, 0xc2,
			0x8b, 0x85, 0x5c, 0xfb, 0xff, 0xff, 0xe8, 0x89,
			0x3c, 0x24, 0x89, 0xc6, 0xe8, 0x89, 0xf0, 0x8b,
			0x5d, 0xf4, 0x8b, 0x75, 0xf8, 0x8b, 0x7d, 0xfc,
			0xc9, 0xc3			
		};
		
		return ScanMobDevForBinaryPatterns(patterns2, numpats2, patlens2, funcbytes2, sysVersion);
		 */
	}
	
	return NULL;
}

void *MobDevInternals::ScanMobDevForFunction(int func)
{

	if (m_mobDevBuffer == NULL) {
		return NULL;
	}

	void *funcPointer = NULL;

	switch (func) {
		case FUNC_SOCKETFORPORT:
			funcPointer = ScanMobDevForSFP();
			break;
		case FUNC_PERFORMOPERATION:
			funcPointer = ScanMobDevForPO();
			break;
		case FUNC_SENDCOMMANDTODEVICE:
			funcPointer = ScanMobDevForSCTD();
			break;
		case FUNC_SENDFILETODEVICE:
			funcPointer = ScanMobDevForSFTD();
			break;
		default:
			break;
	}

	return funcPointer;
}

bool MobDevInternals::SetupPrivateFunctions()
{
		  
	if (OpenMobDevLibrary() == false) {
		SetInitializationError("Couldn't find Mobile Device library.");
		return false;
	}

	if ( (m_socketForPort = (t_socketForPort)ScanMobDevForFunction(FUNC_SOCKETFORPORT)) == NULL ) {
		SetInitializationError("Couldn't find socketForPort() in Mobile Device library.");
		return false;
	}

	if ( (m_performOperation = (t_performOperation)ScanMobDevForFunction(FUNC_PERFORMOPERATION)) == NULL ) {
		SetInitializationError("Couldn't find performOperation() in Mobile Device library.");
		return false;
	}

	if ( (m_sendCommandToDevice = (t_sendCommandToDevice)ScanMobDevForFunction(FUNC_SENDCOMMANDTODEVICE)) == NULL ) {
		SetInitializationError("Couldn't find sendCommandToDevice() in Mobile Device library.");
		return false;
	}

	if ( (m_sendFileToDevice = (t_sendFileToDevice)ScanMobDevForFunction(FUNC_SENDFILETODEVICE)) == NULL ) {
		SetInitializationError("Couldn't find sendFileToDevice() in Mobile Device library.");
		return false;
	}

	return true;
}

/*
#if defined(WIN32)
bool MobDevInternals::SetupPrivateFunctions(const PIVersion& iTunesVersion)
{
	HMODULE hGetProcIDDLL = GetModuleHandle("iTunesMobileDevice.dll");
	
	if (!hGetProcIDDLL) {
		SetInitializationError("Error obtaining handle to iTunesMobileDevice.dll");
		return false;
	}
	
	if ( iTunesVersion.major != 7 ) {
		SetInitializationError("Error due to bad iTunes version");
		return false;
	}

	switch (iTunesVersion.minor) {
		case 6:

			switch (iTunesVersion.point) {
				case 0:
					m_sendCommandToDevice = (t_sendCommandToDevice)((char*)hGetProcIDDLL+0x00009290);
					m_sendFileToDevice = (t_sendFileToDevice)((char*)hGetProcIDDLL+0x00009410);
					m_socketForPort = (t_socketForPort)((char*)hGetProcIDDLL+0x00012830);
					m_performOperation = (t_performOperation)((char*)hGetProcIDDLL+0x000129C0);
					break;
				default:
					SetInitializationError("Error due to bad iTunes version");
					return false;
					break;
			}

			break;
		case 5:
			// iTunes 7.5 offsets submitted by David Wang
			m_sendCommandToDevice = (t_sendCommandToDevice)((char*)GetProcAddress(hGetProcIDDLL, "AMRestorePerformRecoveryModeRestore")-0x10008FF0+0x10008160);
			m_sendFileToDevice = (t_sendFileToDevice)((char*)GetProcAddress(hGetProcIDDLL, "AMRestorePerformRecoveryModeRestore")-0x10008FF0+0x100082E0);
			m_socketForPort = (t_socketForPort)((char*)GetProcAddress(hGetProcIDDLL, "AMRestorePerformRecoveryModeRestore")-0x10008FF0+0x100130D0);
			m_performOperation = (t_performOperation)((char*)GetProcAddress(hGetProcIDDLL, "AMRestorePerformRecoveryModeRestore")-0x10008FF0+0x100141C0);
			break;			
		case 4:
			m_sendCommandToDevice = (t_sendCommandToDevice)((char*)GetProcAddress(hGetProcIDDLL, "AMRestorePerformRecoveryModeRestore")-0x10008FD0+0x10008170);
			m_sendFileToDevice = (t_sendFileToDevice)((char*)GetProcAddress(hGetProcIDDLL, "AMRestorePerformRecoveryModeRestore")-0x10008FD0+0x100082F0);
			m_socketForPort = (t_socketForPort)((char*)GetProcAddress(hGetProcIDDLL, "AMRestorePerformRecoveryModeRestore")-0x10008FD0+0x10012F90);
			m_performOperation = (t_performOperation)((char*)GetProcAddress(hGetProcIDDLL, "AMRestorePerformRecoveryModeRestore")-0x10008FD0+0x10014040);
			break;
		case 3:
			m_sendCommandToDevice= (t_sendCommandToDevice)((char*)GetProcAddress(hGetProcIDDLL, "AMRestorePerformRecoveryModeRestore")-0x10009F30+0x10009290);
			m_sendFileToDevice= (t_sendFileToDevice)((char*)GetProcAddress(hGetProcIDDLL, "AMRestorePerformRecoveryModeRestore")-0x10009F30+0x10009410);
			m_performOperation= (t_performOperation)((char*)GetProcAddress(hGetProcIDDLL, "AMRestorePerformRecoveryModeRestore")-0x10009F30+0x100129C0);
			m_socketForPort= (t_socketForPort)((char*)GetProcAddress(hGetProcIDDLL, "AMRestorePerformRecoveryModeRestore")-0x10009F30+0x10012830);
			break;
		default:
			SetInitializationError("Error due to bad iTunes version");
			return false;
			break;
	}

	return true;
}
#elif defined(__APPLE__) && defined(__POWERPC__)
bool MobDevInternals::SetupPrivateFunctions(const PIVersion& iTunesVersion)
{
	
	if ( iTunesVersion.major != 7 ) {
		SetInitializationError("Error due to bad iTunes version");
		return false;
	}

	switch (iTunesVersion.minor) {
		case 6:

			switch (iTunesVersion.point) {
				case 1:
					m_socketForPort = (t_socketForPort)0x3c3a1470;
					m_performOperation = (t_performOperation)0x3c3a2064;
					m_sendCommandToDevice = (t_sendCommandToDevice)0x3c3a72b0;
					m_sendFileToDevice = (t_sendFileToDevice)0x3c3a7410;
					break;
				case 0:
					m_socketForPort = (t_socketForPort)0x3c3a1530;
					m_performOperation = (t_performOperation)0x3c3a2124;
					m_sendCommandToDevice = (t_sendCommandToDevice)0x3c3a72cc;
					m_sendFileToDevice = (t_sendFileToDevice)0x3c3a742c;
					break;
				default:
					SetInitializationError("Error due to bad iTunes version");
					return false;
					break;
			}

			break;
		case 5:
			// iTunes 7.5 offsets submitted by David Wang
			m_socketForPort = (t_socketForPort)0x3c3a11d8;
			m_performOperation = (t_performOperation)0x3c3a1884;
			m_sendCommandToDevice = (t_sendCommandToDevice)0x3c3a693c;
			m_sendFileToDevice = (t_sendFileToDevice)0x3c3a6a9c;
			break;
		case 4:
			m_socketForPort = (t_socketForPort)0x3c3a051c;
			m_performOperation = (t_performOperation)0x3c3a0bc8;
			m_sendCommandToDevice = (t_sendCommandToDevice)0x3c3a5bb0;
			m_sendFileToDevice = (t_sendFileToDevice)0x3c3a5d10;
			break;
		case 3:
			m_socketForPort = (t_socketForPort)0x3c3a0644;
			m_performOperation = (t_performOperation)0x3c3a0e14;
			m_sendCommandToDevice = (t_sendCommandToDevice)0x3c3a517c;
			m_sendFileToDevice = (t_sendFileToDevice)0x3c3a52dc;
			break;
		default:
			SetInitializationError("Error due to bad iTunes version");
			return false;
			break;
	}

	return true;
}
#elif defined(__APPLE__)
bool MobDevInternals::SetupPrivateFunctions(const PIVersion& iTunesVersion)
{
	
	if ( iTunesVersion.major != 7 ) {
		SetInitializationError("Error due to bad iTunes version");
		return false;
	}

	switch (iTunesVersion.minor) {
		case 6:

			switch (iTunesVersion.point) {
				case 1:
					m_socketForPort = (t_socketForPort)0x3c3a116b;
					m_performOperation = (t_performOperation)0x3c3a1c05;
					m_sendCommandToDevice = (t_sendCommandToDevice)0x3c3a71d7;
					m_sendFileToDevice = (t_sendFileToDevice)0x3c3a72fc;
					break;
				case 0:
					m_socketForPort = (t_socketForPort)0x3c3a122b;
					m_performOperation = (t_performOperation)0x3c3a1cc5;
					m_sendCommandToDevice = (t_sendCommandToDevice)0x3c3a71dd;
					m_sendFileToDevice = (t_sendFileToDevice)0x3c3a7302;
					break;
				default:
					SetInitializationError("Error due to bad iTunes version");
					return false;
					break;
			}

			break;
		case 5:
			// iTunes 7.5 offsets submitted by David Wang
			m_socketForPort = (t_socketForPort)0x3c39fcff;
			m_performOperation = (t_performOperation)0x3c3a02f5;
			m_sendCommandToDevice = (t_sendCommandToDevice)0x3c3a57a3;
			m_sendFileToDevice = (t_sendFileToDevice)0x3c3a59ef;
			break;
		case 4:
			m_socketForPort = (t_socketForPort)0x3c39ffa3;
			m_performOperation = (t_performOperation)0x3c3a0599;
			m_sendCommandToDevice = (t_sendCommandToDevice)0x3c3a597f;
			m_sendFileToDevice = (t_sendFileToDevice)0x3c3a5bcb;
			break;
		case 3:
			m_socketForPort = (t_socketForPort)0x3c39f36c;
			m_performOperation = (t_performOperation)0x3c39fa4b;
			m_sendCommandToDevice = (t_sendCommandToDevice)0x3c3a3e3b;
			m_sendFileToDevice = (t_sendFileToDevice)0x3c3a4087;
			break;
		default:
			SetInitializationError("Error due to bad iTunes version");
			return false;
			break;
	}

	return true;
}
#endif
 */

int MobDevInternals::socketForPort(am_restore_device *rdev, unsigned int portnum)
{

	if (!m_socketForPort) return 1;

	int retval = 0;

#if defined (WIN32)
	asm("push %1\n\t"
		"push %3\n\t"
		"call *%0\n\t"
		"movl %%eax, %2"
		:
		:"m"(m_socketForPort), "g"(portnum), "m"(retval), "m"(rdev)
		:);
#elif defined (__APPLE__)
    retval = m_socketForPort(rdev, portnum);
#else
	retval = 1;
	printf("socketForPort not implemented on your platform\n");
#endif
	
	return retval;
}

int MobDevInternals::performOperation(am_restore_device *rdev, CFDictionaryRef cfdr)
{

	if (!m_performOperation) return 1;

	int retval = 0;
	
#if defined (WIN32)
	asm("movl %2, %%esi\n\t"
		"movl %3, %%ebx\n\t"
		"call *%0\n\t"
		"movl %%eax, %1"
		:
		:"m"(m_performOperation), "m"(retval), "m"(rdev), "m"(cfdr)
		:);
#elif defined (__APPLE__)
	retval = m_performOperation(rdev, cfdr);
#else
	retval = 1;
	printf("performOperation not implemented on your platform\n");
#endif
	
	return retval;      
}

int MobDevInternals::sendCommandToDevice(am_recovery_device *rdev, CFStringRef cfs)
{

	if (!m_sendCommandToDevice) return 1;

	int retval = 0;
	
#if defined (WIN32)
	asm("movl %3, %%esi\n\t"
		"push %1\n\t"
		"call *%0\n\tmovl %%eax, %2"
		:
		:"m"(m_sendCommandToDevice),  "m"(cfs), "m"(retval), "m"(rdev)
		:);
#elif defined (__APPLE__)
	retval = m_sendCommandToDevice(rdev, cfs);
#else
	retval = 1;
	printf("sendCommandToDevice not implemented on your platform\n");
#endif
	
    return retval;
}

int MobDevInternals::sendFileToDevice(am_recovery_device *rdev, CFStringRef filename)
{

	if (!m_sendFileToDevice) return 1;

	int retval = 0;
	
#if defined (WIN32)
	asm("movl %3, %%ecx\n\t"
		"push %1\n\t"
		"call *%0\n\t"
		"movl %%eax, %2"
		:
		:"m"(m_sendFileToDevice),  "m"(filename), "m"(retval), "m"(rdev)
		:);
#elif defined (__APPLE__)
	retval = m_sendFileToDevice(rdev, filename);
#else
	retval = 1;
	printf("sendFileToDevice not implemented on your platform\n");
#endif
	
	return retval;
}
